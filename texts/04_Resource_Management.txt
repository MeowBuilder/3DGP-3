# 리소스 관리 시스템 (Resource Management System)

## 1. 텍스처 관리 (Texture Management)

### CTexture 클래스
- D3D12 텍스처 리소스(`ID3D12Resource`)와 해당 리소스의 서술자(Descriptor)를 관리합니다.
- **레퍼런스 카운팅**: 여러 재질(`CMaterial`)이 동일한 텍스처를 공유할 수 있도록 `AddRef()`와 `Release()`를 통해 생명 주기를 관리합니다.
- **로드 방식**:
    - `LoadTextureFromFile` 메서드를 통해 DDS 파일(`DDSTextureLoader12`) 또는 일반 이미지 파일(`WICTextureLoader12`)을 로드합니다.
    - 로드 시 `CScene`이 관리하는 전역 서술자 힙(Descriptor Heap)에서 CPU/GPU 핸들을 할당받아 SRV(Shader Resource View)를 생성합니다.
- **루트 파라미터 바인딩**: 렌더링 시 자신의 핸들을 커맨드 리스트의 루트 파라미터(주로 텍스처 슬롯)에 설정하여 쉐이더가 접근할 수 있게 합니다.

## 2. 메쉬 관리 (Mesh Management)

### CMesh 및 CStandardMesh
- **버퍼 관리**: 정점 버퍼(Vertex Buffer)와 인덱스 버퍼(Index Buffer)를 `ID3D12Resource` 형태로 생성하고, 이를 가리키는 뷰(VBV, IBV)를 유지합니다.
- **업로드 힙**: 리소스 생성 시 `D3D12_HEAP_TYPE_UPLOAD`를 사용하여 CPU 데이터를 GPU로 복사하거나, 정적 메쉬의 경우 `D3D12_HEAP_TYPE_DEFAULT`로 복사 후 업로드 버퍼를 해제하는 최적화를 수행할 수 있습니다.
- **파일 로드**: `CStandardMesh::LoadMeshFromFile`은 바이너리 또는 텍스트 형식의 모델 파일을 파싱하여 정점 및 인덱스 데이터를 구성합니다. 파일 포맷은 프로젝트 자체 규격(`.bin`, `.txt`)을 따릅니다.

## 3. 쉐이더 및 재질 관리 (Shader & Material)

### CShader
- 쉐이더 코드는 실행 시점에 `D3DCompileFromFile` 등을 통해 컴파일되거나, 컴파일된 바이트코드를 읽어옵니다.
- 각 쉐이더 객체는 고유한 PSO를 가지며, 이는 재사용됩니다.

### CMaterial
- `CShader`에 대한 포인터와 `CTexture`들에 대한 포인터 배열을 가집니다.
- 실제 렌더링 시 어떤 쉐이더(알고리즘)로 어떤 텍스처(데이터)를 입힐지 결정하는 연결 고리 역할을 합니다.
- 재질 역시 레퍼런스 카운팅을 통해 여러 게임 오브젝트가 공유할 수 있습니다.

## 4. 메모리 관리 전략
- **소유권**: `CScene`이 대부분의 리소스에 대한 최상위 소유권을 가지거나 관리를 위임받습니다.
- **정적 관리**: 런타임에 빈번한 생성/삭제보다는, 초기화 시점(`BuildObjects`)에 필요한 리소스를 모두 로드하고 게임 종료 시 해제하는 방식을 주로 사용합니다.
- **스마트 포인터**: 명시적인 `AddRef/Release` 패턴을 사용하므로, `std::shared_ptr`보다는 자체적인 참조 계수 시스템을 따르고 있음을 유의해야 합니다.
